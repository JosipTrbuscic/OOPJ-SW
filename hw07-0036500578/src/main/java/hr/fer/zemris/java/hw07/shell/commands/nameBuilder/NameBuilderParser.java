package hr.fer.zemris.java.hw07.shell.commands.nameBuilder;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to parse output file name format 
 * and generate {@link NameBuilder}s
 * @author Josip Trbuscic
 */
public class NameBuilderParser {
	/**
	 *Array where string is stored.
	 */
	private char[] data;

	/**
	 * Current position in array
	 */
	private int currentIndex;
	
	/**
	 * List of generated {@link NameBuilder}s
	 */
	private List<NameBuilder> nameBuilders;
	
	/**
	 * Constructs new parser and starts parsing
	 * @param expression - file name format
	 */
	public NameBuilderParser(String expression) {
		data = expression.toCharArray();
		currentIndex=0;
		nameBuilders = new ArrayList<>();
		parse();
	}
	
	/**
	 * Parses the expression and generates the 
	 * list of {@link NameBuilder}s
	 */
	private void parse() {
		while(true) {
			String text = getText();
			if(text.length() == 0) break;
			
			nameBuilders.add(new NameBuilderLiteral(text));
			if(currentIndex >= data.length) break;
			
			String group = getGroup();
			if(group == null) {
				throw new IllegalArgumentException("Invalid group tag arguments");
			}
			
			String[] parts = group.split(",");
			if(parts.length == 2) {
	 			nameBuilders.add(new NameBuilderGroup(Integer.parseInt(parts[0]), parts[1]));
			} else {
				nameBuilders.add(new NameBuilderGroup(Integer.parseInt(parts[0]),null));
			}
			
		}
	}
	
	/**
	 * Extracts next string literal from expression
	 * @return string literal
	 */
	private String getText() {
		int startIndex = currentIndex;
		
		while (currentIndex < data.length) {
			char c = data[currentIndex];

			if (c == '$' && currentIndex + 1 < data.length && data[currentIndex + 1] == '{') {
				int endIndex = currentIndex;
				currentIndex +=2;
				return new String(data, startIndex, endIndex - startIndex);
			}

			currentIndex++;
		}

		return new String(data, startIndex, currentIndex - startIndex);
	}
	
	/**
	 * Extracts next parameters of matcher group string format
	 * @return parameters of matcher group string format
	 */
	private String getGroup() {
		int startIndex = currentIndex;
		
		while (currentIndex < data.length) {
			char c = data[currentIndex];

			if (c == '}') {
				currentIndex++;
				break;
			}

			currentIndex++;
		}
		
		String s = new String(data, startIndex, currentIndex - startIndex-1);
		Pattern p = Pattern.compile("^\\s*((\\d)+|((\\d)+\\s*,\\s*(\\d)+))\\s*$");
		
		Matcher m = p.matcher(s);
		
		if(!m.find()) {
			return null;
		}
		return s;
	}
	
	/**
	 * Returns new {@link NameBuilderFinal} object which 
	 * contains all NameBuilders generated by this parser
	 * @return new {@link NameBuilderFinal} object
	 */
	public NameBuilder getNameBuilder() {
		return new NameBuilderFinal(nameBuilders);
	}
	
}
