package hr.fer.zemris.java.custom.scripting.exec;

import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Stack;

import hr.fer.zemris.java.custom.scripting.elems.Element;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantDouble;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantInteger;
import hr.fer.zemris.java.custom.scripting.elems.ElementFunction;
import hr.fer.zemris.java.custom.scripting.elems.ElementOperator;
import hr.fer.zemris.java.custom.scripting.elems.ElementString;
import hr.fer.zemris.java.custom.scripting.elems.ElementVariable;
import hr.fer.zemris.java.custom.scripting.nodes.DocumentNode;
import hr.fer.zemris.java.custom.scripting.nodes.EchoNode;
import hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode;
import hr.fer.zemris.java.custom.scripting.nodes.INodeVisitor;
import hr.fer.zemris.java.custom.scripting.nodes.TextNode;
import hr.fer.zemris.java.custom.scripting.parser.SmartScriptParser;
import hr.fer.zemris.java.webserver.RequestContext;

/**
 * Class that executes script parsed by {@link SmartScriptParser}
 * and writes the result to request context
 * @author Josip Trbuscic
 *
 */
public class SmartScriptEngine {
	
	/**
	 * Document node
	 */
	private DocumentNode documentNode;
	
	/**
	 * Request context
	 */
	private RequestContext requestContext;
	
	/**
	 * Stack
	 */
	private ObjectMultistack multistack = new ObjectMultistack();

	/**
	 * Visitor of nodes generated by parser
	 */
	private INodeVisitor visitor = new INodeVisitor() {

		@Override
		public void visitTextNode(TextNode node) {

			try {
				requestContext.write(node.toString());
			} catch (IOException e) {
				throw new RuntimeException("Unable to write");
			}

		}

		@Override
		public void visitForLoopNode(ForLoopNode node) {
			String variable = node.getVariable().asText();
			ValueWrapper startValue = new ValueWrapper(node.getStartExpression().asText());
			ValueWrapper endValue = new ValueWrapper(node.getEndExpression().asText());
			ValueWrapper stepValue = new ValueWrapper(node.getStepExpression().asText());

			while (startValue.numCompare(endValue.getValue()) <= 0) {
				multistack.push(variable, startValue);
				int j = 0;
				while (j < node.numberOfChildren()) {
					node.getChild(j).accept(visitor);
					j++;
				}
				startValue.add(stepValue.getValue());
			}

			multistack.pop(variable);

		}

		@Override
		public void visitEchoNode(EchoNode node) {
			Stack<Object> tempStack = new Stack<>();
			boolean firstEl = true;

			for (Element el : node.getElements()) {
				if (firstEl) {
					firstEl = false;
					continue;
				}
				if (el instanceof ElementString) {
					tempStack.push(((ElementString) el).getValue().replace("\"", ""));
				} else if (el instanceof ElementConstantDouble) {
					tempStack.push(((ElementConstantDouble) el).getValue());
				} else if (el instanceof ElementConstantInteger) {
					tempStack.push(((ElementConstantInteger) el).getValue());
				} else if (el instanceof ElementVariable) {
					Object val = multistack.peek(((ElementVariable) el).getName()).getValue();
					tempStack.push(val);
				} else if (el instanceof ElementOperator) {
					ValueWrapper second = new ValueWrapper(tempStack.pop());
					ValueWrapper first = new ValueWrapper(tempStack.pop());

					ValueWrapper result = doOperation(first, second, (ElementOperator) el);
					tempStack.push(result.getValue());
				} else if (el instanceof ElementFunction) {
					ElementFunction function = (ElementFunction) el;
					doFunction(function.asText(), tempStack);
				}
			}
			Stack<Object> reverse = new Stack<>();
			while (!tempStack.isEmpty()) {
				reverse.push(tempStack.pop());
			}
			while (!reverse.isEmpty()) {
				try {
					requestContext.write(reverse.pop().toString());
				} catch (IOException ignorable) {
				}
			}

		}

		/**
		 * Performs given function on given stack of arguments
		 * @param function - function
		 * @param tempStack - stack of arguments
		 */
		private void doFunction(String function, Stack<Object> tempStack) {
			function = function.substring(1);
			switch (function) {
			case "sin":
				ValueWrapper arg = new ValueWrapper(tempStack.pop());
				tempStack.push(Math.sin(Double.parseDouble(arg.getValue().toString())));
				break;
			case "decfmt":
				String formatString = (String) tempStack.pop();
				DecimalFormat format = new DecimalFormat(formatString);
				Double val = (Double) tempStack.pop();
				tempStack.push(format.format(val));
				break;
			case "dup":
				tempStack.push(tempStack.peek());
			case "swap":
				Object temp1 = tempStack.pop();
				Object temp2 = tempStack.pop();
				tempStack.push(temp1);
				tempStack.push(temp2);
				break;
			case "setMimeType":
				requestContext.setMimeType((String) tempStack.pop());
				break;
			case "paramGet":
				Object dv = tempStack.pop();
				Object name = tempStack.pop();
				Object value = requestContext.getParameter(name.toString());
				value = value == null ? dv : value;
				tempStack.push(value);
				break;
			case "pparamGet":
				Object dvp = tempStack.pop();
				Object namep = tempStack.pop();
				Object valuep = requestContext.getPersistentParameter(namep.toString().trim());
				valuep = valuep == null ? dvp : valuep;
				tempStack.push(valuep);
				break;
			case "pparamSet":
				Object nam = tempStack.pop();
				Object val2 = tempStack.pop();
				requestContext.setPersistentParameter(nam.toString().trim(), val2.toString());

				break;
			case "pparamDel":
				requestContext.removePersistentParameter(tempStack.pop().toString());
				break;
			case "tparamGet":
				Object dvt = tempStack.pop();
				Object namet = tempStack.pop();
				Object valuet = requestContext.getTemporaryParameter(namet.toString());
				valuet = valuet == null ? dvt : valuet;
				tempStack.push(valuet);
				break;
			case "tparamSet":
				Object namt = tempStack.pop();
				Object valt = tempStack.pop();
				requestContext.setTemporaryParameter(namt.toString(), valt.toString());
				break;
			case "tparamDel":
				requestContext.removeTemporaryParameter(tempStack.pop().toString());
				break;
			default:
				throw new IllegalArgumentException("Invalid function");
			}

		}

		/**
		 * Performs arithmetic operation specified by given operator
		 * @param first -first operator
		 * @param second - second operator
		 * @param elOp - operator
		 * @return result of arithmetic operator
		 */
		private ValueWrapper doOperation(ValueWrapper first, ValueWrapper second, ElementOperator elOp) {

			String operator = elOp.getSymbol();
			switch (operator) {
			case "+":
				first.add(second.getValue());
				return first;
			case "-":
				first.substract(second.getValue());
				return first;
			case "*":
				first.multiply(second.getValue());
				return first;
			case "/":
				first.divide(second.getValue());
				return first;
			default:
				throw new IllegalArgumentException("Invalid operator");
			}
		}

		@Override
		public void visitDocumentNode(DocumentNode node) {
			int i = 0;
			while (i < node.numberOfChildren()) {
				node.getChild(i).accept(visitor);
				i++;
			}
		}
	};

	/**
	 * Constructor
	 * @param documentNode - document node
	 * @param requestContext - request context
	 */
	public SmartScriptEngine(DocumentNode documentNode, RequestContext requestContext) {
		this.documentNode = documentNode;
		this.requestContext = requestContext;
	}

	/**
	 * Executes the parsed script
	 */
	public void execute() {
		documentNode.accept(visitor);
	}

}
