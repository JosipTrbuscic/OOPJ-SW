package hr.fer.zemris.java.custom.scripting.parser;

import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.List;
import java.util.Stack;

import hr.fer.zemris.java.custom.scripting.elems.Element;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantDouble;
import hr.fer.zemris.java.custom.scripting.elems.ElementConstantInteger;
import hr.fer.zemris.java.custom.scripting.elems.ElementFunction;
import hr.fer.zemris.java.custom.scripting.elems.ElementOperator;
import hr.fer.zemris.java.custom.scripting.elems.ElementString;
import hr.fer.zemris.java.custom.scripting.elems.ElementVariable;
import hr.fer.zemris.java.custom.scripting.nodes.DocumentNode;
import hr.fer.zemris.java.custom.scripting.nodes.EchoNode;
import hr.fer.zemris.java.custom.scripting.nodes.ForLoopNode;
import hr.fer.zemris.java.custom.scripting.nodes.Node;
import hr.fer.zemris.java.custom.scripting.nodes.TextNode;

/**
 * Simple parser that parses given string by grouping tokens generated by
 * {@code Lexer} and storing them as a tree structure.
 * 
 * @author Josip Trbuscic
 *
 */
public class SmartScriptParser {
	private DocumentNode document; // head node
	private Stack<Object> stack = new Stack<>(); // stack data structure
	private Lexer lexer;

	/**
	 * Constructs new {@code SmartScriptParser} and starts parsing given document.
	 * 
	 * @param document
	 * @throws NullPointerException
	 *             if document is null
	 */
	public SmartScriptParser(String document) {
		if (document == null)
			throw new NullPointerException();

		this.document = new DocumentNode();
		lexer = new Lexer(document);
		parse(lexer);
	}

	/**
	 * Parses document by grouping tokens given by {@code Lexer} in a tree. Parsing
	 * is finished when end of document is reached or exception is thrown
	 * 
	 * @param lexer
	 *            that creates token
	 * @throws SmartScriptParserException
	 *             if document cannot be parsed
	 */
	public void parse(Lexer lexer) {
		stack.push(document);

		while (true) {
			Token token;

			try {
				token = lexer.nextToken();
			} catch (LexerException ex) {
				throw new SmartScriptParserException("");
			}

			Node node;

			if (token.getType().equals(TokenType.EOF)) {
				break;
			}

			if (token.getType().equals(TokenType.TEXT)) {
				String s = (String) token.getValue();
				ElementString el = new ElementString(s);

				node = new TextNode(el);
				Node parent = (Node) stack.peek();

				parent.addChildNode(node);

				continue;

			} else if (token.getType().equals(TokenType.SOT)) {
				lexer.setState(LexerState.TAG_STATE);
				parseTag();
				lexer.setState(LexerState.TEXT_STATE);
			} else {
				throw new SmartScriptParserException("Invalid document");
			}
		}

		if (stack.size() != 1) {
			throw new SmartScriptParserException("Too many END tags");
		}

	}

	/**
	 * When start of tag is reached this method will parse the tag until tag is
	 * closed, end of file is reached or exception is thrown
	 * 
	 * @throws SmartScriptParserException
	 *             if tag cannot be parsed
	 */
	private void parseTag() {
		ArrayList<Object> params = new ArrayList<>();
		Node node;

		try {
			Token token = lexer.nextToken();
			while (!token.getType().equals(TokenType.EOT)) {
				params.add(token);
				token = lexer.nextToken();
			}
		} catch (LexerException ex) {
			throw new SmartScriptParserException("Invalid tag expression.");
		}

		Token tagName = (Token) params.get(0);
		
		if (tagName.getValue().toString().toLowerCase().equals("for")) {
			node = parseForTag(params);

			Node parent = (Node) stack.peek();

			parent.addChildNode(node);
			stack.push(node);
		}else if (tagName.getValue().toString().toLowerCase().equals("end")) {
			if (params.size() != 1)
				throw new SmartScriptParserException();

			try {
				stack.pop();
				if (stack.isEmpty()) {
					throw new SmartScriptParserException("Too many END tags");
				}
			} catch (EmptyStackException ex) {
				throw new SmartScriptParserException("Too many END tags");
			}

		} else if (tagName.getValue().equals("=") || tagName.getType().equals(TokenType.VARIABLE)) {
			node = parseEmptyTag(params);

			Node parent = (Node) stack.peek();

			parent.addChildNode(node);
		}  else {
			throw new SmartScriptParserException();
		}

	}

	/**
	 * Parses empty tag
	 * 
	 * @param params
	 *            - Collection where tokens are stored
	 * @return EchoNode that will be added to the tree
	 */
	private EchoNode parseEmptyTag(List<Object> params) {
		Element[] elements = new Element[params.size()];

		for (int i = 0, size = params.size(); i < size; ++i) {
			Token token = (Token) params.get(i);

			if (i == 0 && token.getValue().equals("=")) {
				elements[i] = new ElementVariable((String) token.getValue());
			} else {
				elements[i] = elementCreator(token);
			}
		}

		return new EchoNode(elements);

	}

	/**
	 * Parses for tag
	 * 
	 * @param params
	 *            - Collection where tokens are stored
	 * @return ForLoopNode that will be added to the tree
	 */
	private ForLoopNode parseForTag(List<Object> params) {
		if (params.size() != 4 && params.size() != 5)
			throw new SmartScriptParserException("Invalid FOR parameters count");

		if (checkForArgs(params)) {
			Token first = (Token) params.get(1);
			Token second = (Token) params.get(2);
			Token third = (Token) params.get(3);
			Token fourth = null;

			if (params.size() == 4) {
				;

				return new ForLoopNode((ElementVariable) elementCreator(first), elementCreator(second),
						(Element) elementCreator(third));
			} else {
				fourth = (Token) params.get(4);

				return new ForLoopNode((ElementVariable) elementCreator(first), elementCreator(second),
						(Element) elementCreator(third), (Element) elementCreator(fourth));
			}
		}
		throw new SmartScriptParserException("Invalid FOR parameters");

	}

	/**
	 * This method will check if {@code FoorLoopNode} can be created out of given
	 * arguments
	 * 
	 * @param params
	 *            - arguments
	 * @return true if arguments are valid, false otherwise
	 */
	private boolean checkForArgs(List<Object> params) {

		for (int i = 1; i < params.size(); ++i) {
			Token token = (Token) params.get(i);

			if (i == 1 && !token.getType().equals(TokenType.VARIABLE)) {
				throw new SmartScriptParserException("Invalid FOR argument");
			}

			if (token.getType().equals(TokenType.OPERATOR) || token.getType().equals(TokenType.FUNCTION)) {
				throw new SmartScriptParserException("Invalid FOR argument");
			}
		}

		return true;
	}

	/**
	 * Method will create proper {@code Element} object
	 * depending on type of given token
	 * @param token 
	 * @throws SmartScriptParser if token type is invalid
	 */
	private Element elementCreator(Token token) {
		if (token.getType().equals(TokenType.DOUBLE)) {
			return new ElementConstantDouble((Double) token.getValue());

		} else if (token.getType().equals(TokenType.INTEGER)) {
			return new ElementConstantInteger((Integer) token.getValue());

		} else if (token.getType().equals(TokenType.FUNCTION)) {
			return new ElementFunction((String) token.getValue());

		} else if (token.getType().equals(TokenType.OPERATOR)) {
			return new ElementOperator((String) token.getValue());

		} else if (token.getType().equals(TokenType.TEXT)) {
			return new ElementString((String) token.getValue());

		} else if (token.getType().equals(TokenType.VARIABLE)) {
			return new ElementVariable((String) token.getValue());

		} else {
			throw new SmartScriptParserException("Illegal Empty tag argument");
		}

	}

	/**
	 * @return tree head
	 */
	public DocumentNode getDocumentNode() {
		return document;
	}

}
